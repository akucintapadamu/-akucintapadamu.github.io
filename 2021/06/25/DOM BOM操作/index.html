<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="欲望受到侵蚀 行动定要受阻">
  
  <title>
    DOM BOM操作 |
    
    柯
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-DOM BOM操作" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  DOM BOM操作
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/06/25/DOM%20BOM%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2021-06-25T09:31:25.000Z" itemprop="datePublished">2021-06-25</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/ES6/">ES6</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-JavaScript/">浏览器脚本语言(JavaScript)</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>关于JS对DOM（BOM）的一些简单操作</p>
<span id="more"></span>

<h3 id="一、DOM"><a href="#一、DOM" class="headerlink" title="一、DOM"></a>一、DOM</h3><h4 id="1、获取元素"><a href="#1、获取元素" class="headerlink" title="1、获取元素"></a>1、获取元素</h4><p>（1）获取元素</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>document.getElementById(<em>id</em>)</td>
<td>通过元素 id 来查找元素（大小写敏感）</td>
</tr>
<tr>
<td>document.getElementsByTagName(<em>name</em>)</td>
<td>通过标签名来查找元素</td>
</tr>
<tr>
<td>document.getElementsByClassName(<em>classname</em>)</td>
<td>通过类名来查找元素（H5）</td>
</tr>
<tr>
<td>document.querySelector(<em>选择器</em>)</td>
<td>返回指定选择器的第一个元素对象（H5）</td>
</tr>
<tr>
<td>document.querySelectorAll(<em>选择器</em>)</td>
<td>根据指定选择器返回（H5）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;.类名&#x27;);</span><br><span class="line">document.querySelector(&#x27;#id&#x27;);</span><br><span class="line">document.querySelector(&#x27;标签名&#x27;)</span><br></pre></td></tr></table></figure>

<p>（2）获取body和HTML</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bodyEle=document.body//获取body</span><br><span class="line"></span><br><span class="line">var htmlEle=document.documentElement//获取html</span><br></pre></td></tr></table></figure>



<h4 id="2、事件基础"><a href="#2、事件基础" class="headerlink" title="2、事件基础"></a>2、事件基础</h4><p>事件由三部分组成：事件源、事件类型、事件处理程序，也称为事件三要素</p>
<ul>
<li><p>事件源 事件被触发的对象  谁 ：按钮</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick</span><br></pre></td></tr></table></figure></li>
<li><p>事件处理程序  通过一个函数赋值的方式 完成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3、API和Web-API"><a href="#3、API和Web-API" class="headerlink" title="3、API和Web API"></a>3、API和Web API</h4><p>API(application programing interface)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或者硬件得以访问一组例程的能力，而又无需访问源码，或者理解内部工作机制的细节</p>
<p>简单理解就是：API是给程序员提供的一种工具，以便能轻松的实现想要完成的功能。</p>
<p>比如手机充电，我们要实现充电这个功能：</p>
<ul>
<li>不关心手机内部变压器，如何存储点</li>
<li>不关心充电线怎么制作</li>
<li>只需要知道，拿着充电线插进充电接口就可以充电</li>
<li>这个充电接口就是一个API</li>
</ul>
<p>Web API 是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）</p>
<p>主要学习针对浏览器做交互效果的Web API</p>
<p>比如我们想要浏览器弹出一个警示框，直接使用alter(‘弹出’)即可</p>
<ul>
<li>Web API一般都有输入和输出（函数的传参和返回值），Web API很多都是方法（或者函数）</li>
<li>不关心充电线怎么制作</li>
<li>只需要知道，拿着充电线插进充电接口就可以充电</li>
<li>这个充电接口就是一个API</li>
</ul>
<h4 id="4、操作元素"><a href="#4、操作元素" class="headerlink" title="4、操作元素"></a>4、操作元素</h4><p>（1）操作元素的内容</p>
<p>   innerText和innerHTM的区别（普通盒子拥有的属性）</p>
<p>   ①innerText不识别html标签、非标准（IE发起的）、会去除空格、换行和html标签</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.innerText=<span class="string">&#x27;&lt;strong&gt;今天是周二&lt;/strong&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>   ②innerHTML识别html标签 、 W3C标准、保留空格、换行和html标签</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var div=document.querySelector(&#x27;div&#x27;);</span><br><span class="line">div.innerHTML=&#x27;&lt;strong&gt;今天是周二&lt;/strong&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>   ③都是可以读写的，不仅可以修改，还可以读取，可以获取里面的内容</p>
<p>(2) 常用元素的属性操作</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innerText、innerHTML改变元素内容</span><br><span class="line">src、href</span><br><span class="line">id、alt、title</span><br></pre></td></tr></table></figure>

<p>(3) 表单元素的属性操作</p>
<p>   利用DOM可以操作下表单元素的属性</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type、value、checked、selected、disable</span><br></pre></td></tr></table></figure>

<p>(4)样式属性操作</p>
<p>   可以通过JS修改元素的大小、颜色、位置等样式。</p>
<p>   ①element.style            行内样式操作（驼峰）</p>
<ul>
<li>​    JS里面的样式采取驼峰命名法 ：fontSize、backgroundColor</li>
<li>​    JS修改style样式操作，产生的行内样式，CSS权重比较高</li>
</ul>
<p>   ②element.className 类名样式操作  适合样式多，元素复杂的内容</p>
<ul>
<li><p>样式修改多，可以采取操作类名方式更改元素样式</p>
</li>
<li><p>class因为是个保留字，因此className来操作元素类名属性</p>
</li>
<li><p>className会直接更改元素的类名，会覆盖原先的类名，保留原先的类名，可以写多类名选择器</p>
</li>
</ul>
<p>(5) 排他思想</p>
<p>(6) 自定义属性的操作</p>
<p>   ①获取属性值</p>
<ul>
<li>element.属性   获取内置属性值（元素本身自带的属性）</li>
<li>element.getAttribute(‘属性’) 主要获得自定义的属性（标准）</li>
</ul>
<p>   ②设置属性值</p>
<ul>
<li><p>element.属性==’值’   设置内置属性值（元素本身自带的属性）</p>
</li>
<li><p>element.setAttribute(‘属性’，’值’)</p>
</li>
<li><p>class特殊值</p>
<p>div.className=’footer’</p>
<p>div.setAttribute(‘class’,’footer)</p>
</li>
</ul>
<p>   ③移除属性值</p>
<ul>
<li>removeAttribute(‘属性’)</li>
</ul>
<p>(7) H5自定义属性</p>
<p>   ①设置自定义属性：规定自定义属性data-开头作为属性名并且赋值</p>
<p>   ②H5新增element.dataset.index或者element.dataset[‘index’] ——ie11才开始支持</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-index=&#x27;1&#x27; data-list-time-name=&#x27;20&#x27;&gt;123&lt;/div&gt;</span><br><span class="line">var index=div.dataset.index;</span><br><span class="line">var index1=div.dataset[&#x27;listTimeName&#x27;];//驼峰命名法</span><br></pre></td></tr></table></figure>



<h4 id="5、节点操作"><a href="#5、节点操作" class="headerlink" title="5、节点操作"></a>5、节点操作</h4><p>（1） 获取元素常用两种操作</p>
<ul>
<li>利用DOM提供的方法：逻辑性不强、繁琐</li>
</ul>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;div&#x27;)</span><br><span class="line">document.querySelector(&#x27;div&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>利用节点层级关系获取元素：利用父子兄节点获取关系，逻辑性强，但是兼容性较差</li>
</ul>
<p>（2） 节点概述</p>
<p>   网页中所有内容都是节点（标签、属性、文本、注释等），在DOM中，节点使用node来表示。</p>
<p>   HTML DOM树中所有节点均可以通过JS进行访问，所有HTML元素（节点）均可修改，也可以创建或删除。</p>
<p>   一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）这三个基本属性。</p>
<ul>
<li><p>元素节点 nodeType为1 （<strong>实际操作中，节点操作主要操作的是元素节点</strong>）</p>
</li>
<li><p>属性节点 nodeType为2</p>
</li>
<li><p>文本节点 nodeType为3（文本节点包括文字、空格、换行等）</p>
</li>
</ul>
<p>   <img src="http://r4rg6x7uh.hn-bkt.clouddn.com/image-20220105202226025.png"> </p>
<p>（3） 节点层级</p>
<p>   利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系</p>
<p>   ①父级节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.parentNode//得到的是离元素最近的父级节点，如果找不到就返回为null，</span><br><span class="line">       所有子节点包含元素节点和子节点等等，所有主要浏览器都支持 parentNode 属性</span><br><span class="line"></span><br><span class="line">node.parentElement//只读属性返回指定元素的父元素。</span><br><span class="line">       如果指定的元素没有父元素，则此属性返回null,所有浏览器完全支持parentElement属性</span><br></pre></td></tr></table></figure>

<p>   ②子节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parent.childNodes(标准)//返回包括指定节点的子节点的集合，</span><br><span class="line">    该集合为即时更新的集合，所有子节点包含元素节点和子节点等等</span><br><span class="line"></span><br><span class="line">parent.children(非标准)//只读属性，返回所有的子元素节点。</span><br><span class="line">    只返回子 元素节点，其余节点不返回，虽然为非标准，但得到了各个浏览器的支持</span><br></pre></td></tr></table></figure>

<p>   ③第一个子节点 </p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.firstChild//不管是文本节点还是元素节点(IE9以上)</span><br><span class="line"></span><br><span class="line">parent.lastChild</span><br></pre></td></tr></table></figure>

<p>   ④返回第一个子元素节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.firstElementChild//(IE9以上)，找不到返回null</span><br><span class="line"></span><br><span class="line">parent.lastElementChild</span><br></pre></td></tr></table></figure>

<p>   ⑤没有兼容性问题又可以返回第一个子元素</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.children[0]</span><br><span class="line"></span><br><span class="line">parent.children[parent.children.length-1]//最后</span><br></pre></td></tr></table></figure>

<p>   ⑥兄弟节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node.nextSibling//返回当前元素的下一个兄弟节点，</span><br><span class="line">      找不到返回null，包含所有节点，文本（兼容）</span><br><span class="line"></span><br><span class="line">node.previousSibling//返回当前元素的上一个兄弟节点，</span><br><span class="line">      找不到返回null，包含所有节点，文本（兼容）</span><br><span class="line"></span><br><span class="line">node.nextElementSibling//只返回下一个兄弟 元素节点（IE9兼容）</span><br><span class="line"></span><br><span class="line">node.previousElementSibling//只返回上一个兄弟 元素节点（IE9兼容）</span><br></pre></td></tr></table></figure>

<p>（4） 页面添加新元素</p>
<p>   ①创建节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(&#x27;tagName&#x27;)创建的由tagName指定的HTML元素，</span><br><span class="line">因为这些元素原先不存在，是根据需求动态生成的，也称为动态创建元素节点</span><br></pre></td></tr></table></figure>

<p>   ②添加节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.appendChild(child)//追加节点，</span><br><span class="line">         将一个节点添加到指定父节点的子节点列表末尾，类似与css里面的after伪元素</span><br><span class="line"></span><br><span class="line">node.insertBefore(li,node.children[0]);将一个节点添加到指定父</span><br><span class="line">         节点的指定子节点前面，类似与css里面的before伪元素</span><br></pre></td></tr></table></figure>

<p>   ③删除节点</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.removeChild(child)//从DOM中删除一个子节点，返回删除的节点</span><br></pre></td></tr></table></figure>

<p>   ④复制节点（克隆节点）</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.cloneNode()//返回调用该方法的一个副本，也成为了克隆、拷贝节点</span><br></pre></td></tr></table></figure>

<ul>
<li>括号参数为空或者false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点</li>
<li>括号为true，则是深拷贝，复制克隆里面的子节点</li>
</ul>
<p>（5） 三种动态创建元素区别</p>
<ul>
<li> document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘</li>
<li>innerHTML是将内容写入某个DOM节点，不会导致页面全部重绘</li>
<li>innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</li>
<li>createElement()创建多个元素效率稍微低一些，但是结构清晰</li>
</ul>
<h3 id="二、DOM高级事件"><a href="#二、DOM高级事件" class="headerlink" title="二、DOM高级事件"></a>二、DOM高级事件</h3><h4 id="1、注册事件（绑定事件）"><a href="#1、注册事件（绑定事件）" class="headerlink" title="1、注册事件（绑定事件）"></a>1、注册事件（绑定事件）</h4><p>给元素添加事件，称为注册事件或者绑定事件</p>
<p>注册事件有两种方式：方法监听注册、传统注册</p>
<p>（1）传统注册方法</p>
<ul>
<li>on开头的事件</li>
<li>特点：注册事件的唯一性，他同一个元素同一个事件只能设置一个处理函数，后注册会覆盖前注册的</li>
</ul>
<p>（2）方法监听注册方法</p>
<ul>
<li>addEventListener()是一个方法</li>
<li>IE9之前不支持，可使用attachEvent()代替（不提倡、非标准）</li>
<li>特点：同一个元素同一个事件可以注册多个监听器，按照注册顺序依次执行</li>
</ul>
<h4 id="2、删除事件（解绑事件）"><a href="#2、删除事件（解绑事件）" class="headerlink" title="2、删除事件（解绑事件）"></a>2、删除事件（解绑事件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.传统注册</span><br><span class="line">divs[0].onclick=function()&#123;&#125;</span><br><span class="line">//1.传统解绑</span><br><span class="line">divs[0].onclick=null</span><br><span class="line"></span><br><span class="line">//2.绑定</span><br><span class="line">divs[1].removeEventListener(&#x27;click&#x27;,fn);</span><br><span class="line">//2.解绑</span><br><span class="line">divs[1].addEventListener(&#x27;click&#x27;,fn);</span><br></pre></td></tr></table></figure>



<h4 id="3、DOM事件流"><a href="#3、DOM事件流" class="headerlink" title="3、DOM事件流"></a>3、DOM事件流</h4><p>（1）事件流介绍</p>
<p><strong>事件流</strong>描述的是从页面接受事件的顺序</p>
<p><strong>事件</strong>发生时会在元素节点之间按照特定的<strong>顺序</strong>传播，这个<strong>传播过程</strong>即<strong>DOM事件流</strong></p>
<p>比如给div注册了点击事件：</p>
<p>DOM事件流分为3个阶段：</p>
<p>​    1.捕获阶段</p>
<p>​    2.当前目标阶段</p>
<p>​    3.冒泡阶段</p>
<p><img src="http://r4rg6x7uh.hn-bkt.clouddn.com/image-20220106201538755.png" alt="image-20220106201538755"> </p>
<p>事件捕获：望京最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程</p>
<p>事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程</p>
<p>（2）注意</p>
<ul>
<li>JS代码中只能执行捕获或者冒泡其中的一个阶段</li>
<li>onclick 和 attachEvent只能得到冒泡阶段</li>
<li>addEventListener第三个参数true为捕获阶段，默认false为冒泡阶段</li>
<li>开发中更关注<strong>事件冒泡</strong></li>
<li><strong>有些事件没有冒泡</strong>，如<strong>onblur、onfocus、onmouseover、onmouseleave</strong></li>
</ul>
<h4 id="4、事件对象"><a href="#4、事件对象" class="headerlink" title="4、事件对象"></a>4、事件对象</h4><p>（1）事件对象介绍</p>
<ul>
<li>event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看</li>
<li>事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</li>
<li>事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息 比如 鼠标坐标，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键</li>
<li>这个事件对象我们可以自己命名 比如 event 、 evt、 e</li>
<li>事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;</li>
</ul>
<p>（2）事件对象常见属性和方法</p>
<table>
<thead>
<tr>
<th>事件对象属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的对象（标准）点击哪个元素 就返回哪个元素</td>
</tr>
<tr>
<td>e.srcElement</td>
<td>返回触发事件的对象（非标准） ie6-8使用</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型 如click mouseover 不带on</td>
</tr>
<tr>
<td>e.cancelBubble</td>
<td>该属性阻止冒泡</td>
</tr>
<tr>
<td>e.returnValue</td>
<td>该属性 阻止默认事件（默认行为） （非标准） ie6-8使用 比如不让链接跳转</td>
</tr>
<tr>
<td>e.preventDefault</td>
<td>该方法 阻止默认事件（默认行为） （标准） 比如不让链接跳转</td>
</tr>
<tr>
<td>e.stopPropagation</td>
<td>阻止冒泡 （标准）</td>
</tr>
</tbody></table>
<h4 id="5、阻止事件冒泡"><a href="#5、阻止事件冒泡" class="headerlink" title="5、阻止事件冒泡"></a>5、阻止事件冒泡</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation() （有兼容性）</span><br><span class="line">window.event.cancelBubble=true//ie678</span><br></pre></td></tr></table></figure>



<h4 id="6、事件委托（代理、委派）"><a href="#6、事件委托（代理、委派）" class="headerlink" title="6、事件委托（代理、委派）"></a>6、事件委托（代理、委派）</h4><p>事件冒泡本身的特性可以让一个统一的元素做代理。不让每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置的每个子节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;知否知否&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;知否知否&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>点击每个li都会弹出对话框，访问DOM次数多，会延长整个页面交互的时间。把事件交给ul，只操作一次DOM，提高程序性能</p>
<h4 id="7、常用的鼠标事件"><a href="#7、常用的鼠标事件" class="headerlink" title="7、常用的鼠标事件"></a>7、常用的鼠标事件</h4><p>（1）鼠标事件</p>
<table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标点击左键触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标经过触发</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开出发</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得鼠标焦点触发</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点触发</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动触发</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标弹起触发</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下触发</td>
</tr>
</tbody></table>
<ol>
<li>contextmenu 我们可以禁用右键菜单  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>禁止选中文字 selectstart</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）鼠标事件对象mouseEvent(就是下表的e)</p>
<table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.clientX</td>
<td>返回鼠标相对于浏览器窗口可视区的X坐标</td>
</tr>
<tr>
<td>e.clientY</td>
<td>返回鼠标相对于浏览器窗口可视区的X坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回鼠标相对于文档页面的X坐标（IE9+支持）</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回鼠标相对于文档页面的Y坐标（IE9+支持）</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对于电脑屏幕的X坐标</td>
</tr>
<tr>
<td>e.screenY</td>
<td>返回鼠标相对于电脑屏幕的X坐标</td>
</tr>
</tbody></table>
<h4 id="8、常用的键盘事件"><a href="#8、常用的键盘事件" class="headerlink" title="8、常用的键盘事件"></a>8、常用的键盘事件</h4><p>(1)键盘事件</p>
<table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onkeyup</td>
<td>某个键盘按键被松开时触发</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下时触发</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键被按下时触发(不识别功能键，比如ctrl shift 箭头等)</td>
</tr>
</tbody></table>
<ul>
<li>这三个事件的执行顺序：onkeydown——&gt;onkeypress——&gt;onkeyup</li>
<li>keyup和keydown不区分大小写，a和A得到的都是65</li>
<li>keypress区分字母大小写，a得到97，A得到65</li>
</ul>
<p>（2）键盘事件对象keyboardEvent(就是下表的e)</p>
<table>
<thead>
<tr>
<th>键盘事件对象属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keyCode</td>
<td>返回该键的的ASCII值</td>
</tr>
</tbody></table>
<h3 id="三、BOM"><a href="#三、BOM" class="headerlink" title="三、BOM"></a>三、BOM</h3><h4 id="1、BOM概述"><a href="#1、BOM概述" class="headerlink" title="1、BOM概述"></a>1、BOM概述</h4><p>（1）BOM概述</p>
<p>BOM（Browser Object Model）即<strong>浏览器对象</strong>模型，他提供了独立于内容而与浏览器窗口进行交互的<strong>对象</strong>，其核心顶级对象是window。</p>
<p>BOM由一系列的对象构成，并且每个对象都提供了很多方法和属性。</p>
<p>BOM缺乏标准，JS语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初的Netscape浏览器标准的一部分（兼容性比较差）。</p>
<table>
<thead>
<tr>
<th>DOM</th>
<th>BOM</th>
</tr>
</thead>
<tbody><tr>
<td>文档对象模型</td>
<td>浏览器对象模型</td>
</tr>
<tr>
<td>DOM就是把<strong>文档</strong>当做一个<strong>对象</strong>来看待</td>
<td>把<strong>浏览器</strong>当作一个<strong>对象</strong>来看待</td>
</tr>
<tr>
<td>DOM的顶级对象是<strong>document</strong></td>
<td>BOM的顶级对象是<strong>window</strong></td>
</tr>
<tr>
<td>DOM主要学习的是操作页面元素</td>
<td>BOM学习的是浏览器窗口交互的一些对象</td>
</tr>
<tr>
<td>DOM是W3C标准</td>
<td>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差</td>
</tr>
</tbody></table>
<p>（2）BOM构成</p>
<p><img src="http://r4rg6x7uh.hn-bkt.clouddn.com/image-20220107151316650.png"></p>
<ul>
<li>window是JS访问浏览器窗口的一个接口。</li>
<li>window是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li>
<li>window有个特殊的属性：window.name</li>
</ul>
<h4 id="2、window对象的常见操作"><a href="#2、window对象的常见操作" class="headerlink" title="2、window对象的常见操作"></a>2、window对象的常见操作</h4><p>（1）窗口加载（onload和DOMContentLoaded）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123; &#125;</span><br><span class="line">window.addEventListener(&#x27;load&#x27;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p> window.onload是窗口（页面）加载事件，当文档内容完全加载完成才会触发该事件（包括图像、脚本文件、CSS文件等）</p>
<ul>
<li>可以把JS卸载页面元素的上方，因为onload是等页面全部加载完毕，再去执行处理函数。</li>
<li>window.onload传统注册事件方式只能写一次，如果有多个，以最后一个为准</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;)//ie9以上支持</span><br></pre></td></tr></table></figure>

<p>DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表、图片、flash等 。</p>
<ul>
<li>如果页面图片非常多的话，从用户访问到onload触发可能需要比较长的时间，交互效果就不能实现，必然影响到用户体验，此时用DOMContentLoaded事件比较合适                    </li>
</ul>
<p>（2）调整窗口大小事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.onresize=function()&#123; &#125;</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>只要窗口大小发生像素变化，就会触发</li>
<li>利用该事件完成响应式布局</li>
</ul>
<h4 id="3、定时器"><a href="#3、定时器" class="headerlink" title="3、定时器"></a>3、定时器</h4><p>（1）创建定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var time1=setTimeout(fn,[延迟毫秒数])//time1是这个定时器的标识符</span><br><span class="line"></span><br><span class="line">var time2=setInterval(fn,间隔毫秒数)</span><br></pre></td></tr></table></figure>

<p>setTimeout称为回调（等别的事干完以后再回头调用一下）函数callback</p>
<p>（2）停止定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.clearTimeout(定时器的标识符)</span><br><span class="line"></span><br><span class="line">window.clearInterval(定时器的标识符)</span><br></pre></td></tr></table></figure>

<p>（3）this指向问题</p>
<ul>
<li>全局作用域或者普通函数中this指向全局对象window(定时器里面的this指向window)</li>
<li>方法调用中谁调用this指向谁</li>
<li>构造函数中this指向创建的实例</li>
</ul>
<h4 id="4、JS执行机制"><a href="#4、JS执行机制" class="headerlink" title="4、JS执行机制"></a>4、JS执行机制</h4><p>（1）同步任务</p>
<p>同步任务都在主线程上执行，形成一个<strong>执行栈</strong></p>
<p>（2）异步任务</p>
<p>JS的异步是通过<strong>回调函数</strong>实现的，一般而言，异步任务有以下的三种类型：</p>
<ul>
<li>普通事件。如click、resize等</li>
<li>资源加载。如load、error等</li>
<li>定时器。包括setInterval、setTimeout等</li>
</ul>
<p>异步任务相关<strong>回调函数</strong>添加到<strong>任务队列</strong>中（<strong>任务队列</strong>也称为<strong>消息队列</strong>）</p>
<p>（3）JS执行机制</p>
<p><img src="http://r4rg6x7uh.hn-bkt.clouddn.com/image-20220107174421421.png"></p>
<h4 id="5、location对象"><a href="#5、location对象" class="headerlink" title="5、location对象"></a>5、location对象</h4><p>（1）location对象属性</p>
<table>
<thead>
<tr>
<th>location对象属性</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.href</td>
<td>获取或者设置整个URL</td>
</tr>
<tr>
<td>location.host</td>
<td>返回主机（域名）</td>
</tr>
<tr>
<td>location.port</td>
<td>返回端口号 如果没写返回空字符串</td>
</tr>
<tr>
<td>location.pathname</td>
<td>返回路径</td>
</tr>
<tr>
<td>location.search</td>
<td>返回参数</td>
</tr>
<tr>
<td>location.hash</td>
<td>返回片段 #后面内容 常见于链接 锚点</td>
</tr>
</tbody></table>
<p>（2）location对象方法</p>
<table>
<thead>
<tr>
<th>location对象方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.assign()</td>
<td>跟href一样，可以跳转页面（也称之为重定向页面），记录历史，能后退页面</td>
</tr>
<tr>
<td>location.replace()</td>
<td>替换当前页面，因为不记录历史，所以不能后退页面</td>
</tr>
<tr>
<td>location.reload()</td>
<td>重新加载页面，相当于刷新按钮或者F5（缓存），如果参数为true，强制刷新 Ctrl+F5（不缓存）</td>
</tr>
</tbody></table>
<h4 id="6、navigation对象"><a href="#6、navigation对象" class="headerlink" title="6、navigation对象"></a>6、navigation对象</h4><p>navigator对象包含有关浏览器的信息，它有很多属性，我们常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|</span><br><span class="line">    iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|</span><br><span class="line">    wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;</span><br><span class="line">            window.location.href = &quot;&quot;; //手机</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="7、history对象"><a href="#7、history对象" class="headerlink" title="7、history对象"></a>7、history对象</h4><p>window对象提供了一个history对象，对浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>可以后退</td>
</tr>
<tr>
<td>forward()</td>
<td>可以前进</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能 参数是1，前进1个页面，参数是-1，后退1个页面</td>
</tr>
</tbody></table>

      
    </div>
    <!-- <footer class="article-footer">
      <a data-url="http://example.com/2021/06/25/DOM%20BOM%E6%93%8D%E4%BD%9C/" data-id="cky595kpb0006l0vo1yu24wbq" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM-BOM%E6%93%8D%E4%BD%9C/" rel="tag">DOM BOM操作</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer> -->

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/08/13/BrowingPrinciple/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      浏览器是如何工作的
      
    </div>
  </a>
  
  
  <a href="/2021/04/07/css%E5%9F%BA%E7%A1%80/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">CSS基础</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i>
     <!-- <span id="busuanzi_value_site_uv"></span> -->
    </li>
  
  <li><i class="fe fe-bookmark"></i> 
    <span id="busuanzi_value_page_pv"></span>
  </li>
  
</ul>     
    </div>
    
    <ul class="list-inline">
      <li>柯 &copy; 2022</li>
      
        <li>ZHWANGART</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
     
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/star.svg" alt="柯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
   
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop" style="width: 5rem;height:5rem;">
  <i class="fe fe-rocket" ></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>